"""
In this module, we do some of the preparatory work that is needed to get
CoolProp ready to build.  This includes setting the correct versions in the 
headers, generating the fluid files, etc.
"""
from __future__ import division, print_function
from datetime import datetime
import subprocess
import os
import sys
import json
import hashlib

def get_hash(data):
    return hashlib.sha224(data).hexdigest()

repo_root_path = os.path.normpath(os.path.join(os.path.abspath(__file__),'..','..'))

# Load up the hashes of the data that will be written to each file
hashes_fname = os.path.join(repo_root_path,'dev','hashes.json')
if os.path.exists(hashes_fname):
    hashes = json.load(open(hashes_fname,'r'))
else:
    hashes = dict()

def version_to_file(root_dir):
    
    # Get the version from the version.txt file
    version = open(os.path.join(root_dir,'version.txt'),'r').read().strip()
    
    # Get the hash of the version
    if 'version' not in hashes or ('version' in hashes and hashes['version'] != get_hash(version)):
        print('*** Generating cpversion.h ***')
        hashes['version'] = get_hash(version)
        
        # Format the string to be written
        string_for_file = '//Generated by the generate_headers.py script on {t:s}\n\nstatic char version [] ="{v:s}";'.format(t = str(datetime.now()),v = version)
        
        # Include path relative to the root
        include_dir = os.path.join(root_dir,'include')
        
        # The name of the file to be written into
        file_name = os.path.join(include_dir,'cpversion.h')
        
        # Write to file
        f = open(file_name,'w')
        f.write(string_for_file)
        f.close()
    else:
        print('cpversion.h is up to date')
    
def gitrev_to_file(root_dir):
    """
    If a git repo, use git to update the gitrevision.  If not a git repo, read 
    the gitrevision from the gitrevision.txt file.  Otherwise, fail.
    """
    
    try:
        try:
            subprocess.check_call('git --version', shell=True)
            print('git is accessible at the command line')
        except subprocess.CalledProcessError:
            print('git was not found')
            return
        p = subprocess.Popen('git rev-parse HEAD', 
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE,
                             shell = True)
        stdout, stderr = p.communicate()

        # Include path relative to the root
        include_dir = os.path.join(root_dir,'include')
        
        if p.returncode != 0:
            print('tried to update git revision, but it failed for some reason (building from zip file?)')
            gitrev = '???'
        else:
            gitrev = stdout.strip()
            print('git revision is', gitrev)
            
            try:
                is_hash = gitrev.find(' ') == -1 # python 2.x
            except TypeError:
                is_hash = ' ' not in str(gitrev) # python 3.x
                                
            if not is_hash:
                raise ValueError('No hash returned from call to git, got '+rev+' instead')
        
        if 'gitrevision' not in hashes or ('gitrevision' in hashes and hashes['gitrevision'] != get_hash(gitrev)):
            print('*** Generating gitrevision.h ***')
            gitstring = '//Generated by the generate_headers.py script on {t:s}\n\nstd::string gitrevision = \"{rev:s}\";'.format(t = str(datetime.now()), rev = gitrev)
        
            f = open(os.path.join(include_dir,'gitrevision.h'),'w')
            f.write(gitstring)
            f.close()
            
            hashes['gitrevision'] = get_hash(gitrev)
        else:
            print('gitrevision.h is up to date')
                
    except (subprocess.CalledProcessError,OSError):
        pass
    
if __name__=='__main__':
    
    import shutil
    shutil.copy2(os.path.join(repo_root_path, 'externals','Catch','single_include','catch.hpp'),os.path.join(repo_root_path,'include','catch.hpp'))

    version_to_file(root_dir = repo_root_path)
    gitrev_to_file(root_dir = repo_root_path)
    
    import JSON_to_CPP
    JSON_to_CPP.TO_CPP(root_dir = repo_root_path, hashes = hashes)

    # Write the hashes to a hashes JSON file
    if hashes:
        fp = open(hashes_fname,'w')
        fp.write(json.dumps(hashes))
        fp.close()

